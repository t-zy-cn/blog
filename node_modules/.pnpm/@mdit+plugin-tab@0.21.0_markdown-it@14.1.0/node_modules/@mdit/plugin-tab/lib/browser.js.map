{"version":3,"file":"browser.js","sources":["../../helper/lib/index.js","../src/plugin.ts"],"sourcesContent":["const l=e=>{const n=e.split(`\n`),p=n.reduce((r,c)=>{for(let t=0;t<c.length;t++)if(c[t]!==\" \"&&c[t]!==\"\t\")return Math.min(t,r);return r},1/0);return p<1/0?n.map(r=>r.slice(p)).join(`\n`):e},a=e=>e.replace(/&/gu,\"&amp;\").replace(/</gu,\"&lt;\").replace(/>/gu,\"&gt;\").replace(/\"/gu,\"&quot;\").replace(/'/gu,\"&#39;\"),g=e=>e.replace(/[-/\\\\^$*+?.()|[\\]{}]/g,\"\\\\$&\"),u=/\\r\\n?|\\n/g,s=/\\\\([ \\\\!\"#$%&'()*+,./:;<=>?@[\\]^_`{|}~-])/gu;export{u as NEWLINE_RE,s as UNESCAPE_RE,l as dedent,a as escapeHtml,g as escapeRegExp};\n//# sourceMappingURL=index.js.map\n","import { escapeHtml } from \"@mdit/helper\";\nimport type { Options, PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type Renderer from \"markdown-it/lib/renderer.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type {\n  MarkdownItTabData,\n  MarkdownItTabInfo,\n  MarkdownItTabOptions,\n} from \"./options.js\";\n\nconst MIN_MARKER_NUM = 3;\nconst TAB_MARKER = `@tab`;\nconst TAB_MARKER_LENGTH = TAB_MARKER.length;\n\nconst getTabRule =\n  (name: string, store: { state: string | null }): RuleBlock =>\n  (state, startLine, endLine, silent) => {\n    if (store.state !== name) return false;\n\n    const currentLineStart = state.bMarks[startLine] + state.tShift[startLine];\n    const currentLineMax = state.eMarks[startLine];\n    const currentLineIndent = state.sCount[startLine];\n\n    /*\n     * Check out the first character quickly,\n     * this should filter out most of non-uml blocks\n     */\n    if (state.src.charAt(currentLineStart) !== \"@\") return false;\n\n    // Check out the rest of the marker string\n    for (let index = 0; index < TAB_MARKER_LENGTH; index++)\n      if (TAB_MARKER[index] !== state.src[currentLineStart + index])\n        return false;\n\n    const markup = state.src.slice(\n      currentLineStart,\n      currentLineStart + TAB_MARKER_LENGTH,\n    );\n    const info = state.src.slice(\n      currentLineStart + TAB_MARKER_LENGTH,\n      currentLineMax,\n    );\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine + 1;\n    let autoClosed = false;\n\n    // Search for the end of the block\n    for (\n      ;\n      // nextLine should be accessible outside the loop,\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine;\n      nextLine++\n    ) {\n      const nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n\n      if (\n        // closing fence should be indented same as opening one\n        state.sCount[nextLine] === currentLineIndent &&\n        // match start\n        state.src[nextLineStart] === \"@\"\n      ) {\n        let openMakerMatched = true;\n\n        for (let index = 0; index < TAB_MARKER.length; index++)\n          if (TAB_MARKER[index] !== state.src[nextLineStart + index]) {\n            openMakerMatched = false;\n            break;\n          }\n\n        if (openMakerMatched) {\n          // found!\n          autoClosed = true;\n          break;\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n    const oldBlkIndent = state.blkIndent;\n\n    // @ts-expect-error: We are creating a new type called \"tab\"\n    state.parentType = `tab`;\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine - (autoClosed ? 1 : 0);\n\n    // this will update the block indent\n    state.blkIndent = currentLineIndent;\n\n    const openToken = state.push(`${name}_tab_open`, \"\", 1);\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const [, title, id] = /^(.*?)(?:(?<!\\\\)#([^#]*))?$/.exec(\n      info.replace(/^:active/, \"\"),\n    )!;\n\n    openToken.block = true;\n    openToken.markup = markup;\n    openToken.info = title.trim().replace(/\\\\#/g, \"#\");\n    openToken.meta = {\n      active: info.includes(\":active\"),\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (id) openToken.meta.id = id.trim();\n    openToken.map = [startLine, nextLine - (autoClosed ? 1 : 0)];\n\n    state.md.block.tokenize(\n      state,\n      startLine + 1,\n      nextLine + (autoClosed ? 0 : 1),\n    );\n\n    const closeToken = state.push(`${name}_tab_close`, \"\", -1);\n\n    closeToken.block = true;\n    closeToken.markup = \"\";\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.blkIndent = oldBlkIndent;\n    state.line = nextLine + (autoClosed ? 0 : 1);\n\n    return true;\n  };\n\nconst getTabsRule =\n  (name: string, store: { state: string | null }): RuleBlock =>\n  (state, startLine, endLine, silent) => {\n    const currentLineStart = state.bMarks[startLine] + state.tShift[startLine];\n    const currentLineMax = state.eMarks[startLine];\n    const currentLineIndent = state.sCount[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    if (state.src[currentLineStart] !== \":\") return false;\n\n    let pos = currentLineStart + 1;\n\n    // Check out the rest of the marker string\n    while (pos <= currentLineMax) {\n      if (state.src[pos] !== \":\") break;\n      pos++;\n    }\n\n    const markerCount = pos - currentLineStart;\n\n    if (markerCount < MIN_MARKER_NUM) return false;\n\n    const markup = state.src.slice(currentLineStart, pos);\n    const params = state.src.slice(pos, currentLineMax);\n\n    const [containerName, id = \"\"] = params.split(\"#\", 2);\n\n    if (containerName.trim() !== name) return false;\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine + 1;\n    let autoClosed = false;\n\n    // Search for the end of the block\n    for (\n      ;\n      // nextLine should be accessible outside the loop,\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine;\n      nextLine++\n    ) {\n      const nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n      const nextLineMax = state.eMarks[nextLine];\n\n      if (\n        nextLineStart < nextLineMax &&\n        state.sCount[nextLine] < currentLineIndent\n      )\n        // non-empty line with negative indent should stop the list:\n        // - :::\n        //  test\n        break;\n\n      if (\n        // closing fence should be indented same as opening one\n        state.sCount[nextLine] === currentLineIndent &&\n        // match start\n        \":\" === state.src[nextLineStart]\n      ) {\n        // check rest of marker\n        for (pos = nextLineStart + 1; pos <= nextLineMax; pos++)\n          if (state.src[pos] !== \":\") break;\n\n        // closing code fence must be at least as long as the opening one\n        if (pos - nextLineStart >= markerCount) {\n          // make sure tail has spaces only\n          pos = state.skipSpaces(pos);\n\n          if (pos >= nextLineMax) {\n            // found!\n            autoClosed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n    const oldBlkIndent = state.blkIndent;\n    const oldState = store.state;\n\n    // @ts-expect-error: We are creating a new type called \"${name}_tabs\"\n    state.parentType = `${name}_tabs`;\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine - (autoClosed ? 1 : 0);\n\n    // this will update the block indent\n    state.blkIndent = currentLineIndent;\n\n    const openToken = state.push(`${name}_tabs_open`, \"\", 1);\n\n    openToken.markup = markup;\n    openToken.block = true;\n    openToken.info = containerName;\n    openToken.meta = { id: id.trim() };\n    openToken.map = [startLine, nextLine - (autoClosed ? 1 : 0)];\n\n    store.state = name;\n\n    state.md.block.tokenize(\n      state,\n      startLine + 1,\n      nextLine - (autoClosed ? 1 : 0),\n    );\n\n    store.state = oldState;\n\n    const closeToken = state.push(`${name}_tabs_close`, \"\", -1);\n\n    closeToken.markup = state.src.slice(currentLineStart, pos);\n    closeToken.block = true;\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.blkIndent = oldBlkIndent;\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\nconst getTabsDataGetter =\n  (name: string): ((tokens: Token[], index: number) => MarkdownItTabInfo) =>\n  (tokens, index) => {\n    const tabData: MarkdownItTabData[] = [];\n    let activeIndex = -1;\n    let isTabStart = false;\n    let nestingDepth = 0;\n\n    for (\n      // skip the current tabs_open token\n      let i = index + 1;\n      i < tokens.length;\n      i++\n    ) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const { block, meta, type, info } = tokens[i];\n\n      if (block) {\n        // record the nesting depth of tabs\n        if (type === `${name}_tabs_open`) {\n          nestingDepth++;\n          continue;\n        }\n\n        if (type === `${name}_tabs_close`) {\n          if (nestingDepth === 0) break;\n\n          nestingDepth--;\n          continue;\n        }\n\n        // if we are in a nesting tabs, skip processing\n        if (nestingDepth > 0) continue;\n\n        if (type === `${name}_tab_open`) {\n          isTabStart = true;\n\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          meta.index = tabData.length;\n\n          // tab is active\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          if (meta.active)\n            if (activeIndex === -1) activeIndex = tabData.length;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            else meta.active = false;\n\n          tabData.push({\n            title: info,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            index: meta.index as number,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            ...(meta.id ? { id: meta.id as string } : {}),\n          });\n\n          continue;\n        }\n\n        if (type === `${name}_tab_close`) continue;\n\n        if (!isTabStart) {\n          tokens[i].type = `${name}_tabs_empty`;\n          tokens[i].hidden = true;\n        }\n      }\n    }\n\n    return {\n      active: activeIndex,\n      data: tabData.map((data, index) => ({\n        ...data,\n        active: index === activeIndex,\n      })),\n    };\n  };\n\nconst tabDataGetter = (tokens: Token[], index: number): MarkdownItTabData => {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const { info, meta } = tokens[index];\n\n  return {\n    title: info,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    index: meta.index as number,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    ...(meta.id ? { id: meta.id as string } : {}),\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    isActive: Boolean(meta.active),\n  };\n};\n\nconst store = { state: null };\n\nexport const tab: PluginWithOptions<MarkdownItTabOptions> = (md, options) => {\n  const {\n    name = \"tabs\",\n\n    openRender = (\n      info: MarkdownItTabInfo,\n      tokens: Token[],\n      index: number,\n      _options: Options,\n      _env: unknown,\n      self: Renderer,\n    ): string => {\n      const { active, data } = info;\n      const token = tokens[index];\n\n      token.attrJoin(\"class\", `${name}-tabs-wrapper`);\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (token.meta.id) token.attrJoin(\"data-id\", token.meta.id as string);\n\n      const tabs = data.map(\n        ({ title, id }, index) =>\n          `<button type=\"button\" class=\"${name}-tab-button${\n            active === index ? \" active\" : \"\"\n          }\" data-tab=\"${index}\"${id ? ` data-id=\"${escapeHtml(id)}\"` : \"\"}${\n            active === index ? \" data-active\" : \"\"\n          }>${escapeHtml(title)}</button>`,\n      );\n\n      return `\\\n<div${self.renderAttrs(token)}>\n  <div class=\"${name}-tabs-header\">\n    ${tabs.join(\"\\n    \")}\n  </div>\n  <div class=\"${name}-tabs-container\">\n`;\n    },\n\n    closeRender = (): string => `\\\n  </div>\n</div>\n`,\n\n    tabOpenRender = (\n      info: MarkdownItTabData,\n      tokens: Token[],\n      index: number,\n      _options: Options,\n      _env: unknown,\n      self: Renderer,\n    ): string => {\n      const token = tokens[index];\n\n      token.attrJoin(\n        \"class\",\n        `${name}-tab-content${info.isActive ? \" active\" : \"\"}`,\n      );\n      token.attrSet(\"data-index\", info.index.toString());\n      if (info.id) token.attrSet(\"data-id\", info.id.toString());\n\n      if (info.isActive) token.attrJoin(\"data-active\", \"\");\n\n      return `\\\n<div${self.renderAttrs(tokens[index])}>\n`;\n    },\n\n    tabCloseRender = (): string => `\\\n</div>\n`,\n  } = options ?? {};\n\n  const tabsDataGetter = getTabsDataGetter(name);\n\n  md.block.ruler.before(\"fence\", `${name}_tabs`, getTabsRule(name, store), {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.block.ruler.before(\"paragraph\", `${name}_tab`, getTabRule(name, store), {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.renderer.rules[`${name}_tabs_open`] = (\n    tokens,\n    index,\n    options,\n    env,\n    self,\n  ): string => {\n    const info = tabsDataGetter(tokens, index);\n\n    return openRender(info, tokens, index, options, env, self);\n  };\n\n  md.renderer.rules[`${name}_tabs_close`] = closeRender;\n\n  md.renderer.rules[`${name}_tab_open`] = (tokens, index, ...args): string => {\n    const data = tabDataGetter(tokens, index);\n\n    return tabOpenRender(data, tokens, index, ...args);\n  };\n\n  md.renderer.rules[`${name}_tab_close`] = tabCloseRender;\n};\n"],"names":["a","e","MIN_MARKER_NUM","TAB_MARKER","TAB_MARKER_LENGTH","getTabRule","name","store","state","startLine","endLine","silent","currentLineStart","currentLineMax","currentLineIndent","index","markup","info","nextLine","autoClosed","nextLineStart","openMakerMatched","oldParent","oldLineMax","oldBlkIndent","openToken","title","id","closeToken","getTabsRule","pos","markerCount","params","containerName","nextLineMax","oldState","getTabsDataGetter","tokens","tabData","activeIndex","isTabStart","nestingDepth","i","block","meta","type","data","tabDataGetter","tab","md","options","openRender","_options","_env","self","active","token","tabs","escapeHtml","closeRender","tabOpenRender","tabCloseRender","tabsDataGetter","env","args"],"mappings":"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"}