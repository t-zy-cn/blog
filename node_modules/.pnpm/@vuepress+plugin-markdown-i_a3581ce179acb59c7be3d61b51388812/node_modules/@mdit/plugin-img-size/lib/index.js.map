{"version":3,"file":"index.js","sources":["../src/legacy.ts","../src/obsidian.ts","../src/plugin.ts"],"sourcesContent":["/**\n * Fork and edited from https://github.com/tatsy/markdown-it-imsize/blob/master/lib/index.js\n */\n\nimport type { PluginSimple } from \"markdown-it\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { ImgSizeEnv } from \"./types.js\";\n\n// Parse image size\n//\nconst parseNumber = (\n  str: string,\n  pos: number,\n  max: number,\n): { ok: boolean; pos: number; value: string } => {\n  let char: string;\n  const start = pos;\n  const result = {\n    ok: false,\n    pos: pos,\n    value: \"\",\n  };\n\n  char = str.charAt(pos);\n\n  while ((pos < max && /\\d/.test(char)) || char === \"%\")\n    char = str.charAt(++pos);\n\n  result.ok = true;\n  result.pos = pos;\n  result.value = str.slice(start, pos);\n\n  return result;\n};\n\nconst parseImageSize = (\n  str: string,\n  pos: number,\n  max: number,\n): { pos: number; width: string; height: string } | null => {\n  if (pos >= max) return null;\n\n  if (str.charAt(pos) !== \"=\") return null;\n\n  pos++;\n\n  // size must follow = without any white spaces as follows\n  // (1) =300x200\n  // (2) =300x\n  // (3) =x200\n  const char = str.charAt(pos);\n\n  if (char !== \"x\" && !/\\d/.test(char)) return null;\n\n  // parse width\n  const width = parseNumber(str, pos, max);\n\n  pos = width.pos;\n\n  // next character must be 'x'\n  if (str.charAt(pos) !== \"x\") return null;\n\n  pos++;\n\n  // parse height\n  const height = parseNumber(str, pos, max);\n\n  pos = height.pos;\n\n  return {\n    pos,\n    width: width.value,\n    height: height.value,\n  };\n};\n\nconst legacyImgSizeRule: RuleInline = (state, silent) => {\n  const env = state.env as ImgSizeEnv;\n  const oldPos = state.pos;\n  const max = state.posMax;\n\n  if (\n    state.src.charAt(state.pos) !== \"!\" ||\n    state.src.charAt(state.pos + 1) !== \"[\"\n  )\n    return false;\n\n  const labelStart = state.pos + 2;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) return false;\n\n  let pos = labelEnd + 1;\n  let char: string;\n\n  let href = \"\";\n  let title = \"\";\n  let width = \"\";\n  let height = \"\";\n\n  if (pos < max && state.src.charAt(pos) === \"(\") {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n\n    while (pos < max) {\n      char = state.src.charAt(pos);\n      if (char !== \" \" && char !== \"\\t\") break;\n      pos++;\n    }\n\n    if (pos >= max) return false;\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    let res;\n\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n\n      if (state.md.validateLink(href)) pos = res.pos;\n      else href = \"\";\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    const start = pos;\n\n    for (; pos < max; pos++) {\n      char = state.src.charAt(pos);\n      if (char !== \" \" && char !== \"\\t\") break;\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        char = state.src.charAt(pos);\n        if (char !== \" \" && char !== \"\\t\") break;\n      }\n    } else {\n      title = \"\";\n    }\n\n    // [link](  <href>  \"title\" =WxH  )\n    //                          ^^^^ parsing image size\n    if (pos - 1 >= 0) {\n      char = state.src.charAt(pos - 1);\n\n      // there must be at least one white spaces\n      // between previous field and the size\n      if (char === \" \") {\n        const sizeInfo = parseImageSize(state.src, pos, state.posMax);\n\n        if (sizeInfo) {\n          ({ width, height, pos } = sizeInfo);\n\n          // [link](  <href>  \"title\" =WxH  )\n          //                              ^^ skipping these spaces\n          for (; pos < max; pos++) {\n            char = state.src.charAt(pos);\n            if (char !== \" \" && char !== \"\\n\") break;\n          }\n        }\n      }\n    }\n\n    if (pos >= max || state.src.charAt(pos) !== \")\") {\n      state.pos = oldPos;\n\n      return false;\n    }\n    pos++;\n  } else {\n    let label = \"\";\n\n    //\n    // Link reference\n    //\n    if (typeof env.references === \"undefined\") return false;\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      char = state.src.charAt(pos);\n      if (char !== \" \" && char !== \"\\t\") break;\n    }\n\n    if (pos < max && state.src.charAt(pos) === \"[\") {\n      const start = pos + 1;\n\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n\n      if (pos >= 0) label = state.src.slice(start, pos++);\n      else pos = labelEnd + 1;\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) label = state.src.slice(labelStart, labelEnd);\n\n    const ref = env.references[state.md.utils.normalizeReference(label)];\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!ref) {\n      state.pos = oldPos;\n\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title ?? \"\";\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    const content = state.src.slice(labelStart, labelEnd);\n    const tokens: Token[] = [];\n\n    state.md.inline.parse(content, state.md, state.env, tokens);\n\n    const token = state.push(\"image\", \"img\", 0);\n\n    const attrs: [string, string][] = [\n      [\"src\", href],\n      [\"alt\", \"\"],\n    ];\n\n    if (title) attrs.push([\"title\", title]);\n    if (width) attrs.push([\"width\", width]);\n    if (height) attrs.push([\"height\", height]);\n    token.attrs = attrs;\n\n    token.children = tokens;\n    token.content = content;\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n\n  return true;\n};\n\n/**\n * @deprecated Recommended to use `imgSize` instead.\n */\nexport const legacyImgSize: PluginSimple = (md) => {\n  md.inline.ruler.before(\"emphasis\", \"image\", legacyImgSizeRule);\n};\n","import type { PluginSimple } from \"markdown-it\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { ImgSizeEnv } from \"./types.js\";\n\nconst OBSIDIAN_IMAGE_SIZE_REGEXP = /^(.*?)\\s*\\|\\s*(\\d+)\\s*x\\s*(\\d+)\\s*$/;\n\nexport const obsidianImgSizeRule: RuleInline = (state, silent) => {\n  const env = state.env as ImgSizeEnv;\n  const oldPos = state.pos;\n  const max = state.posMax;\n\n  if (\n    state.src.charAt(state.pos) !== \"!\" ||\n    state.src.charAt(state.pos + 1) !== \"[\"\n  )\n    return false;\n\n  const labelStart = state.pos + 2;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) return false;\n\n  const rawLabel = state.src.slice(labelStart, labelEnd);\n\n  // check if label has img size\n  const matches = OBSIDIAN_IMAGE_SIZE_REGEXP.exec(rawLabel);\n\n  if (!matches) return false;\n\n  const [, label, width, height] = matches;\n  const widthValue = Number(width);\n  const heightValue = Number(height);\n\n  if (!widthValue && !heightValue) return false;\n\n  let pos = labelEnd + 1;\n  let char: string;\n\n  let href = \"\";\n  let title = \"\";\n\n  if (pos < max && state.src.charAt(pos) === \"(\") {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n\n    while (pos < max) {\n      char = state.src.charAt(pos);\n      if (char !== \" \" && char !== \"\\t\") break;\n      pos++;\n    }\n\n    if (pos >= max) return false;\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    let res;\n\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n\n      if (state.md.validateLink(href)) pos = res.pos;\n      else href = \"\";\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    const start = pos;\n\n    for (; pos < max; pos++) {\n      char = state.src.charAt(pos);\n      if (char !== \" \" && char !== \"\\t\") break;\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        char = state.src.charAt(pos);\n        if (char !== \" \" && char !== \"\\t\") break;\n      }\n    } else {\n      title = \"\";\n    }\n\n    if (pos >= max || state.src.charAt(pos) !== \")\") {\n      state.pos = oldPos;\n\n      return false;\n    }\n    pos++;\n  } else {\n    let referenceLabel = \"\";\n\n    //\n    // Link reference\n    //\n    if (typeof env.references === \"undefined\") return false;\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      char = state.src.charAt(pos);\n      if (char !== \" \" && char !== \"\\t\") break;\n    }\n\n    if (pos < max && state.src.charAt(pos) === \"[\") {\n      const start = pos + 1;\n\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n\n      if (pos >= 0) referenceLabel = state.src.slice(start, pos++);\n      else pos = labelEnd + 1;\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!referenceLabel) referenceLabel = label;\n\n    const ref =\n      env.references[state.md.utils.normalizeReference(referenceLabel)];\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!ref) {\n      state.pos = oldPos;\n\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title ?? \"\";\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    const token = state.push(\"image\", \"img\", 0);\n    const attrs: [string, string][] = [\n      [\"src\", href],\n      [\"alt\", \"\"],\n    ];\n\n    if (title) attrs.push([\"title\", title]);\n\n    if (widthValue) attrs.push([\"width\", width]);\n    if (heightValue) attrs.push([\"height\", height]);\n\n    const tokens: Token[] = [];\n\n    state.md.inline.parse(label, state.md, state.env, tokens);\n\n    token.attrs = attrs;\n    token.children = tokens;\n    token.content = label;\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n\n  return true;\n};\n\nexport const obsidianImgSize: PluginSimple = (md) => {\n  md.inline.ruler.before(\"image\", \"obsidian-img-size\", obsidianImgSizeRule);\n};\n","import type { PluginSimple } from \"markdown-it\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { ImgSizeEnv } from \"./types.js\";\n\nconst IMAGE_SIZE_REGEXP = /^(.*?)\\s+=(\\d*)\\s*(?:x(\\d*))?$/;\n\nexport const imgSizeRule: RuleInline = (state, silent) => {\n  const env = state.env as ImgSizeEnv;\n  const oldPos = state.pos;\n  const max = state.posMax;\n\n  if (\n    state.src.charAt(state.pos) !== \"!\" ||\n    state.src.charAt(state.pos + 1) !== \"[\"\n  )\n    return false;\n\n  const labelStart = state.pos + 2;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) return false;\n\n  const rawLabel = state.src.slice(labelStart, labelEnd);\n\n  // check if label has img size\n  const matches = IMAGE_SIZE_REGEXP.exec(rawLabel);\n\n  if (!matches) return false;\n\n  const [, label, width, height] = matches;\n\n  let pos = labelEnd + 1;\n  let char: string;\n\n  let href = \"\";\n  let title = \"\";\n\n  if (pos < max && state.src.charAt(pos) === \"(\") {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n\n    while (pos < max) {\n      char = state.src.charAt(pos);\n      if (char !== \" \" && char !== \"\\t\") break;\n      pos++;\n    }\n\n    if (pos >= max) return false;\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    let res;\n\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n\n      if (state.md.validateLink(href)) pos = res.pos;\n      else href = \"\";\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    const start = pos;\n\n    for (; pos < max; pos++) {\n      char = state.src.charAt(pos);\n      if (char !== \" \" && char !== \"\\t\") break;\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        char = state.src.charAt(pos);\n        if (char !== \" \" && char !== \"\\t\") break;\n      }\n    } else {\n      title = \"\";\n    }\n\n    if (pos >= max || state.src.charAt(pos) !== \")\") {\n      state.pos = oldPos;\n\n      return false;\n    }\n    pos++;\n  } else {\n    let referenceLabel = \"\";\n\n    //\n    // Link reference\n    //\n    if (typeof env.references === \"undefined\") return false;\n\n    // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n    for (; pos < max; pos++) {\n      char = state.src.charAt(pos);\n      if (char !== \" \" && char !== \"\\t\") break;\n    }\n\n    if (pos < max && state.src.charAt(pos) === \"[\") {\n      const start = pos + 1;\n\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n\n      if (pos >= 0) referenceLabel = state.src.slice(start, pos++);\n      else pos = labelEnd + 1;\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!referenceLabel) referenceLabel = label;\n\n    const ref =\n      env.references[state.md.utils.normalizeReference(referenceLabel)];\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!ref) {\n      state.pos = oldPos;\n\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title ?? \"\";\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    const token = state.push(\"image\", \"img\", 0);\n    const attrs: [string, string][] = [\n      [\"src\", href],\n      [\"alt\", \"\"],\n    ];\n\n    if (title) attrs.push([\"title\", title]);\n    if (width) attrs.push([\"width\", width]);\n    if (height) attrs.push([\"height\", height]);\n\n    const tokens: Token[] = [];\n\n    state.md.inline.parse(label, state.md, state.env, tokens);\n\n    token.attrs = attrs;\n    token.children = tokens;\n    token.content = label;\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n\n  return true;\n};\n\nexport const imgSize: PluginSimple = (md) => {\n  md.inline.ruler.before(\"image\", \"img-size\", imgSizeRule);\n};\n"],"names":["parseNumber","str","pos","max","char","start","result","parseImageSize","width","height","legacyImgSizeRule","state","silent","env","oldPos","labelStart","labelEnd","href","title","res","sizeInfo","label","ref","content","tokens","token","attrs","legacyImgSize","md","OBSIDIAN_IMAGE_SIZE_REGEXP","obsidianImgSizeRule","rawLabel","matches","widthValue","heightValue","referenceLabel","obsidianImgSize","IMAGE_SIZE_REGEXP","imgSizeRule","imgSize"],"mappings":"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"}