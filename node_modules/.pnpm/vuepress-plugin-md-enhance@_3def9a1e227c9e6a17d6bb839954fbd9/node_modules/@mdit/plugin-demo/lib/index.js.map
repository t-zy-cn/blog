{"version":3,"file":"index.js","sources":["../src/plugin.ts"],"sourcesContent":["import type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { MarkdownItDemoOptions } from \"./options.js\";\n\nconst MIN_MARKER_NUM = 3;\n\nexport const demo: PluginWithOptions<MarkdownItDemoOptions> = (\n  md,\n  {\n    name = \"demo\",\n    openRender = (tokens: Token[], index: number): string =>\n      `<details><summary>${tokens[index].info.trim()}</summary>\\n`,\n    closeRender = (): string => \"</details>\\n\",\n    codeRender,\n    contentOpenRender,\n    contentCloseRender,\n    showCodeFirst = false,\n  } = {},\n) => {\n  const demoRule: RuleBlock = (state, startLine, endLine, silent) => {\n    const currentLineStart = state.bMarks[startLine] + state.tShift[startLine];\n    const currentLineMax = state.eMarks[startLine];\n    const currentLineIndent = state.sCount[startLine];\n\n    if (state.src.charAt(currentLineStart) !== \":\") return false;\n\n    let pos = currentLineStart + 1;\n\n    // Check out the rest of the marker string\n    while (pos <= currentLineMax) {\n      if (state.src.charAt(pos) !== \":\") break;\n      pos++;\n    }\n\n    const markerCount = pos - currentLineStart;\n\n    if (markerCount < MIN_MARKER_NUM) return false;\n\n    const markup = state.src.slice(currentLineStart, pos);\n    const params = state.src.slice(pos, currentLineMax);\n\n    if (params.trim().split(\" \", 2)[0] !== name) return false;\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine + 1;\n    let autoClosed = false;\n\n    // Search for the end of the block\n    for (\n      ;\n      // nextLine should be accessible outside the loop,\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine;\n      nextLine++\n    ) {\n      const nextLineStart = state.bMarks[nextLine] + state.tShift[nextLine];\n      const nextLineMax = state.eMarks[nextLine];\n\n      if (\n        nextLineStart < nextLineMax &&\n        state.sCount[nextLine] < currentLineIndent\n      )\n        // non-empty line with negative indent should stop the list:\n        // - :::\n        //  test\n        break;\n\n      if (\n        // closing fence should be indented same as opening one\n        state.sCount[nextLine] === currentLineIndent &&\n        // match start\n        \":\" === state.src[nextLineStart]\n      ) {\n        // check rest of marker\n        for (pos = nextLineStart + 1; pos <= nextLineMax; pos++)\n          if (\":\" !== state.src[pos]) break;\n\n        // closing code fence must be at least as long as the opening one\n        if (pos - nextLineStart >= markerCount) {\n          // make sure tail has spaces only\n          pos = state.skipSpaces(pos);\n\n          if (pos >= nextLineMax) {\n            // found!\n            autoClosed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n    const oldBlkIndent = state.blkIndent;\n\n    // @ts-expect-error We are creating a new type called \"demo\"\n    state.parentType = \"demo\";\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    // this will update the block indent\n    state.blkIndent = currentLineIndent;\n\n    const title = params.trim().slice(name.length).trim();\n    const openToken = state.push(\"demo_open\", \"div\", 1);\n\n    openToken.markup = markup;\n    openToken.block = true;\n    openToken.info = title;\n    openToken.map = [startLine, nextLine];\n\n    const pushCodeToken = (): void => {\n      const codeToken = state.push(\n        codeRender ? \"demo_code\" : \"fence\",\n        \"code\",\n        0,\n      );\n\n      const indent = state.sCount[startLine];\n\n      codeToken.content = state.src\n        .split(/\\n\\r?/)\n        .slice(startLine + 1, nextLine)\n        .map((line) => line.substring(indent))\n        // this is a workaround to work with include plugin\n        .filter(\n          (line) => !/^<!-- #include-env-(?:start: .*|end) -->$/.test(line),\n        )\n        .join(\"\\n\")\n        .replace(/^\\n+/, \"\")\n        .replace(/\\n*$/, \"\\n\");\n      codeToken.map = [startLine, state.line];\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      (codeToken.meta ??= {}).title = title;\n      if (!codeRender) codeToken.info = \"md\";\n    };\n\n    if (showCodeFirst) pushCodeToken();\n\n    const contentOpenToken = state.push(\"demo_content_open\", \"div\", 1);\n\n    contentOpenToken.attrPush([\"class\", \"demo-content\"]);\n    contentOpenToken.block = true;\n    openToken.map = [startLine, nextLine];\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    const contentCloseToken = state.push(\"demo_content_close\", \"div\", -1);\n\n    contentCloseToken.block = true;\n\n    if (!showCodeFirst) pushCodeToken();\n\n    const closeToken = state.push(`demo_close`, \"div\", -1);\n\n    closeToken.markup = state.src.slice(currentLineStart, pos);\n    closeToken.block = true;\n    closeToken.info = title;\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.blkIndent = oldBlkIndent;\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\n  md.block.ruler.before(\"fence\", \"demo\", demoRule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n  md.renderer.rules.demo_open = openRender;\n  md.renderer.rules.demo_close = closeRender;\n  if (codeRender) md.renderer.rules.demo_code = codeRender;\n  if (contentOpenRender)\n    md.renderer.rules.demo_content_open = contentOpenRender;\n  if (contentCloseRender)\n    md.renderer.rules.demo_content_close = contentCloseRender;\n};\n"],"names":["demo","md","name","openRender","tokens","index","closeRender","codeRender","contentOpenRender","contentCloseRender","showCodeFirst","demoRule","state","startLine","endLine","silent","currentLineStart","currentLineMax","currentLineIndent","pos","markerCount","markup","params","nextLine","autoClosed","nextLineStart","nextLineMax","oldParent","oldLineMax","oldBlkIndent","title","openToken","pushCodeToken","codeToken","indent","line","contentOpenToken","contentCloseToken","closeToken"],"mappings":"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"}